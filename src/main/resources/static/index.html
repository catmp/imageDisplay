<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Image Wall</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #222;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            user-select: none; /* Prevent text selection */
        }

        .gallery {
            position: relative;
            width: 80vw;
            height: 80vh;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .gallery img {
            position: absolute;
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 10px;
            box-shadow: 2px 4px 10px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-out;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent; /* Remove highlight on tap */
            -webkit-touch-callout: none; /* Disable iOS callout */
            -webkit-user-select: none; /* Safari */
            -khtml-user-select: none; /* Konqueror HTML */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Standard */
            outline: none; /* Remove outline */
            z-index: 1; /* Base z-index */
        }

        .gallery img.selected {
            outline: 2px solid white;
            outline-offset: 2px;
        }

        .gallery img.dragging {
            z-index: 10; /* Higher z-index when dragging */
            transition: none; /* Remove transition for smoother dragging */
        }

        .selection-box {
            position: absolute;
            border: 1px solid white;
            background-color: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
<div class="gallery" id="gallery"></div>

<script>
    // Store original and current positions of images
    const imagePositions = [];
    const currentPositions = [];
    let isSelecting = false;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let selectionBox = null;
    let selectedImageOffsets = [];
    let highestZIndex = 10;

    async function loadImages() {
        try {
            const response = await fetch('/api/images');
            const images = await response.json();
            const gallery = document.getElementById('gallery');

            images.forEach((image, index) => {
                const img = document.createElement('img');
                img.src = `/api/images/${image}`;
                img.alt = image;
                img.draggable = false; // Prevent default drag behavior
                gallery.appendChild(img);

                // Generate random position and rotation
                const top = Math.random() * 60 + 10;
                const left = Math.random() * 60 + 10;
                const rotation = Math.random() * 30 - 15;

                // Store the original position
                imagePositions[index] = {
                    top: top,
                    left: left,
                    rotation: rotation
                };

                // Store current position (will be updated when dragged)
                currentPositions[index] = {
                    top: top,
                    left: left,
                    rotation: rotation
                };

                // Set initial position
                img.style.top = `${top}vh`;
                img.style.left = `${left}vw`;
                img.style.transform = `rotate(${rotation}deg)`;
                img.dataset.index = index;
                img.style.zIndex = 1; // Initial z-index
            });

            // Add event listener for mouse movement with throttling
            let lastMoveTime = 0;
            document.addEventListener('mousemove', (e) => {
                const now = Date.now();
                // Store current mouse position
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                // Throttle to reduce excessive calculations
                if (now - lastMoveTime > 20) { // 50fps limit
                    if (isDragging) {
                        dragSelectedImages(e);
                    } else if (isSelecting) {
                        updateSelectionBox(e);
                    } else {
                        moveImages(e, gallery);
                    }
                    lastMoveTime = now;
                }
            });

            // Add mouse down event for starting the selection rectangle or dragging
            gallery.addEventListener('mousedown', (e) => {
                e.preventDefault(); // Prevent default selection behavior
                handleMouseDown(e);
            });

            // Add mouse up event for ending the selection or dragging
            document.addEventListener('mouseup', (e) => {
                if (isSelecting || isDragging) {
                    e.preventDefault();

                    if (isSelecting) {
                        endSelection(e);
                    } else if (isDragging) {
                        endDrag(e);
                    }
                }
            });

            // Prevent context menu on right-click
            gallery.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
        } catch (error) {
            console.error("Error fetching images:", error);
        }
    }

    function moveImages(event, gallery) {
        const rect = gallery.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        gallery.querySelectorAll('img:not(.selected)').forEach(img => {
            const index = parseInt(img.dataset.index);
            const currentPosition = currentPositions[index];

            // Get the current image position relative to the viewport
            const imgRect = img.getBoundingClientRect();
            const imgCenterX = imgRect.left + imgRect.width / 2;
            const imgCenterY = imgRect.top + imgRect.height / 2;

            // Calculate distance between mouse and image center
            const deltaX = mouseX - (imgCenterX - rect.left);
            const deltaY = mouseY - (imgCenterY - rect.top);
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Repulsion force decreases with distance
            const maxDistance = 300; // Maximum distance for repulsion effect

            if (distance < maxDistance) {
                // Calculate repulsion factor (stronger when closer)
                const repulsionFactor = 1 - (distance / maxDistance);

                // Calculate angle from mouse to image
                const angle = Math.atan2(deltaY, deltaX);

                // Calculate repulsion amount
                const repulsionX = -Math.cos(angle) * 40 * repulsionFactor;
                const repulsionY = -Math.sin(angle) * 40 * repulsionFactor;

                // Apply smooth combined transform
                img.style.transform = `translate(${repulsionX}px, ${repulsionY}px) rotate(${currentPosition.rotation}deg)`;
            } else {
                // Return to original position and rotation
                img.style.transform = `rotate(${currentPosition.rotation}deg)`;
            }
        });
    }

    function handleMouseDown(event) {
        // Get mouse coordinates relative to the gallery
        const rect = document.getElementById('gallery').getBoundingClientRect();
        startX = event.clientX - rect.left;
        startY = event.clientY - rect.top;

        // Check if the click is on an image
        const target = event.target;

        if (target.tagName === 'IMG') {
            // If the clicked image is already selected, start dragging all selected images
            if (target.classList.contains('selected')) {
                startDragging(event);
            } else {
                // If not holding shift, clear previous selections
                if (!event.shiftKey) {
                    document.querySelectorAll('.gallery img.selected').forEach(img => {
                        img.classList.remove('selected');
                    });
                }

                // Toggle selection on the clicked image
                target.classList.toggle('selected');
            }
        } else {
            // If clicking on empty space, start selection rectangle
            isSelecting = true;

            // Create selection box
            selectionBox = document.createElement('div');
            selectionBox.classList.add('selection-box');
            selectionBox.style.left = `${startX}px`;
            selectionBox.style.top = `${startY}px`;
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';

            // Add to gallery
            document.getElementById('gallery').appendChild(selectionBox);

            // Clear any previous selections if not holding shift
            if (!event.shiftKey) {
                document.querySelectorAll('.gallery img.selected').forEach(img => {
                    img.classList.remove('selected');
                });
            }
        }
    }

    function startDragging(event) {
        isDragging = true;
        selectedImageOffsets = [];

        // Increment the highest z-index
        highestZIndex += 1;

        // Calculate the offsets for each selected image and increase z-index
        const selectedImages = document.querySelectorAll('.gallery img.selected');
        selectedImages.forEach(img => {
            const rect = document.getElementById('gallery').getBoundingClientRect();
            const index = parseInt(img.dataset.index);

            // Get the current position in vh/vw
            const currentTop = currentPositions[index].top;
            const currentLeft = currentPositions[index].left;

            // Convert to pixels for precise calculations
            const topPx = (currentTop / 100) * rect.height;
            const leftPx = (currentLeft / 100) * rect.width;

            // Calculate offset from mouse to the top-left corner of each image
            const offsetX = startX - leftPx;
            const offsetY = startY - topPx;

            // Store the offset and element
            selectedImageOffsets.push({
                element: img,
                offsetX: offsetX,
                offsetY: offsetY
            });

            // Add dragging class and increase z-index
            img.classList.add('dragging');
            img.style.zIndex = highestZIndex;
        });
    }

    function dragSelectedImages(event) {
        if (!isDragging) return;

        const gallery = document.getElementById('gallery');
        const galleryRect = gallery.getBoundingClientRect();

        // Get current mouse position relative to gallery
        const currentX = event.clientX - galleryRect.left;
        const currentY = event.clientY - galleryRect.top;

        // Move each selected image
        selectedImageOffsets.forEach(item => {
            // Calculate new position (pixel position - offset)
            const newLeftPx = currentX - item.offsetX;
            const newTopPx = currentY - item.offsetY;

            // Convert to vh/vw
            const newLeft = (newLeftPx / galleryRect.width) * 100;
            const newTop = (newTopPx / galleryRect.height) * 100;

            // Apply new position
            item.element.style.left = `${newLeft}vw`;
            item.element.style.top = `${newTop}vh`;

            // Keep the rotation
            const index = parseInt(item.element.dataset.index);
            const rotation = currentPositions[index].rotation;
            item.element.style.transform = `rotate(${rotation}deg)`;
        });
    }

    function endDrag(event) {
        if (!isDragging) return;

        isDragging = false;

        // Update the stored positions for each moved image
        selectedImageOffsets.forEach(item => {
            const index = parseInt(item.element.dataset.index);
            const computedStyle = window.getComputedStyle(item.element);

            // Extract the top and left values
            let topValue = parseFloat(computedStyle.top);
            let leftValue = parseFloat(computedStyle.left);

            // Handle different units
            if (computedStyle.top.endsWith('vh')) {
                topValue = parseFloat(computedStyle.top);
            } else {
                // Convert px to vh if needed
                const galleryRect = document.getElementById('gallery').getBoundingClientRect();
                topValue = (parseFloat(computedStyle.top) / galleryRect.height) * 100;
            }

            if (computedStyle.left.endsWith('vw')) {
                leftValue = parseFloat(computedStyle.left);
            } else {
                // Convert px to vw if needed
                const galleryRect = document.getElementById('gallery').getBoundingClientRect();
                leftValue = (parseFloat(computedStyle.left) / galleryRect.width) * 100;
            }

            // Update the stored current positions
            if (!isNaN(topValue) && !isNaN(leftValue)) {
                currentPositions[index].top = topValue;
                currentPositions[index].left = leftValue;
            }

            // Remove dragging class but keep the z-index
            item.element.classList.remove('dragging');
        });

        selectedImageOffsets = [];
    }

    function updateSelectionBox(event) {
        if (!isSelecting || !selectionBox) return;

        // Get current mouse position
        const rect = document.getElementById('gallery').getBoundingClientRect();
        const currentX = event.clientX - rect.left;
        const currentY = event.clientY - rect.top;

        // Calculate the dimensions and position
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);

        // Update the selection box
        selectionBox.style.width = `${width}px`;
        selectionBox.style.height = `${height}px`;
        selectionBox.style.left = `${left}px`;
        selectionBox.style.top = `${top}px`;
    }

    function endSelection(event) {
        if (!isSelecting) return;

        isSelecting = false;

        // Get the final selection box dimensions
        const selectionRect = selectionBox.getBoundingClientRect();
        const galleryRect = document.getElementById('gallery').getBoundingClientRect();

        // Check which images are within the selection box
        document.querySelectorAll('.gallery img').forEach(img => {
            const imgRect = img.getBoundingClientRect();

            // Check if the image intersects with the selection box
            if (!(imgRect.right < selectionRect.left ||
                imgRect.left > selectionRect.right ||
                imgRect.bottom < selectionRect.top ||
                imgRect.top > selectionRect.bottom)) {
                img.classList.add('selected');
            }
        });

        // Remove the selection box
        if (selectionBox && selectionBox.parentNode) {
            selectionBox.parentNode.removeChild(selectionBox);
        }
        selectionBox = null;
    }

    loadImages();
</script>
</body>
</html>